WHITESPACE = _{ " " | "\t"}
COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | "//" ~ (!NEWLINE ~ ANY) ~ NEWLINE }

number = @{
      ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
}

identifier = @{
    (LETTER | "_" ) ~ (LETTER | DECIMAL_NUMBER )*
}

char_literal = @{
    "'" ~ (CASED_LETTER | TITLECASE_LETTER) ~ "'"
}

string_literal = ${
    "\"" ~ string_inner ~ "\""
}

string_inner = @{
    string_char*
}

string_char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

function_definition = {
    PUSH(identifier) ~ NEWLINE* ~ "::" ~ NEWLINE* ~ function_type ~ NEWLINE+ ~ function_body+
}

loz_type = _{
    bool_type
    | string_type
    | int_type
    | char_type
    | tuple_type
    | list_type
}

bool_type = { "Bool"}
string_type = {"String"}
int_type = {"Int"}
char_type = {"Char"}
list_type = { "[" ~ loz_type ~ "]"}

tuple_type = { "(" ~ loz_type ~ ("," ~ loz_type)+ ~ ")" }

function_header = ${ PEEK ~ (WHITESPACE+ ~ match_expression)*}
function_let_rule = {NEWLINE ~ ( "let" | "#") ~ match_expression ~ "=" ~ expression}

function_conditional_rule = { NEWLINE ~ function_conditional}

function_expression_rule = {NEWLINE* ~ "=" ~ expression}

function_body = {
    function_header ~
    (
        function_let_rule* ~ function_conditional_rule* ~ function_let_rule* ~ function_expression_rule?
    ) ~ NEWLINE+
}

function_conditional = {
    "|" ~ expression ~ "=" ~ expression
}

function_type = {
    (loz_type ~ NEWLINE*)* ~ NEWLINE? ~ "->" ~ NEWLINE? ~ loz_type
}

call = {
    identifier ~ function_argument+
}

function_argument = {
    simple_term
    | identifier
}

simple_term = _{
    bool_literal
    | string_literal
    | char_literal
    | number
    | subexpr
    | negation
    | minus
    | tuple_literal
    | list_literal
}

minus = @{"-" ~ expression}

term = {
      simple_term
    | call // Function call
    | inline_match
    | identifier // Variable reference
}

inline_match = { identifier ~ ":=" ~ match_expression }
tuple_literal = !{ "(" ~ NEWLINE* ~ expression ~ NEWLINE* ~ ("," ~ NEWLINE* ~ expression)+ ~ NEWLINE* ~ ")" }
list_literal = _{ list_empty
    | list_singleton
    | list_shorthand
    | list_longhand
}

list_empty = {"[]"}
list_singleton = {"[" ~ NEWLINE* ~ expression ~ NEWLINE* ~ "]"}
list_shorthand = {"[" ~ NEWLINE* ~ expression ~ NEWLINE* ~ ("," ~ NEWLINE* ~ expression)* ~ NEWLINE* ~ "]"}
list_longhand = {"[" ~ NEWLINE* ~ expression ~ NEWLINE* ~ ":" ~ NEWLINE* ~ expression ~ NEWLINE* ~ "]"}

bool_literal = { "false" | "true" }
subexpr = { "(" ~ expression ~ ")" }
negation = { "!" ~ expression }

expression = {
    term ~ (operation ~ term)*
}

match_expression = {
    match_term
}

match_term = _{
    list_match
    | tuple_match
    | identifier
    | number
    | char_literal
    | string_literal
    | bool_literal
}

tuple_match = {
    "(" ~ match_term ~ ("," ~ match_term)+ ~ ")"
}

list_match = _{
    list_match_empty
    | list_match_singleton
    | list_match_shorthand
    | list_match_longhand
}

list_match_empty = { "[]" }
list_match_singleton = { "[" ~ match_term ~ "]" }
list_match_shorthand = { "[" ~ match_term ~ ("," ~ match_term)+ ~ "]" }
list_match_longhand = { "[" ~ match_term ~ ":" ~ match_term ~ "]" }

operation = _{
    times | divide | modulo

    | add | substract
    | shift_left | shift_right

    | lesser | leq | greater | greq

    | eq | neq

    | and

    | or

    }

    times = {"*"}
    divide = {"/"}
    modulo = {"%"}

    add = {"+"}
    substract = {"-"}

    shift_left = {"<<"}
    shift_right = {">>"}

    lesser = {"<"}
    leq = {"<="}
    greater = {">"}
    greq = {">="}

    eq = {"=="}
    neq = {"!="}

    and = {"&&"}
    or = {"||"}

main = {"Main" ~ "=" ~ expression }

ast = {
   SOI ~ (function_definition ~ NEWLINE?)* ~ main ~ NEWLINE* ~ EOI
}


